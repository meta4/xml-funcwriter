Easy XML production using Lazy Evaluation, Closures, Currying, and overloaded operators.

* Introduction

This document is an explanation of a perl package I created to write XML fragments the way CGI.pm writes HTML fragments using nested functions.  The functions in this package take a list of entity contents to enclose between XML open and close tags.  They also take an optional hash reference specifying arbitrary XML attributes.  Some of the entity contents might be nested XML entities, which include their own tags, attributes, contents, sub-entities, etc.  The resulting nesting of XML elements should correspond to nested function calls in the code creating the XML fragment.

* Motivation

I wrote this because this package is an interesting exploration of lazy evaluation, closures, and currying function arguments, with a splash of operator overloading for that last little bit of syntactic sugar.  If you do not know what these things are, or you have never seen an demonstration how powerful these things can be, you might find the following interesting.  On the other hand, if you have more experience than I do, you might have suggestions for better ways to accomplish this.

* Instructions

The code in this writeup was designed to be run as you read.  If you create a perl file and paste the code into it as you read, the resulting perl program should execute at the end of each example.  The output from the example code is not included in this writeup to motivate you to actually run the examples.  It might be useful to run the code in the debugger to see exactly how things happen, but, due to the recursive nature of the code, this may cause more confusion than understanding.  If you do use the debugger, watching the $tag variable may help you keep track of where you are in the recursion.

The usual caveats for running someone else's code on your machine apply.  I hope you will  understand the code before you run it.  This works on my machine.  I don't guaranty it works on yours.

Or, you can just read.  I'm not the boss of you.

On to the code!

* Utility Functions

We start with the two standard perl sanity check pragmas, warnings & strict, and two utility functions.  the first function, escape_ents, converts characters not allowed in XML data into their XML representations.  The second function, stringify_attribs, converts a hash into XML attributes to be used in a tag. There are probably more robust ways to accomplish these things but this way works and is simple to understand.

The thing to note in escape_ents is that the characters '<' and '>' are converted to '&lt;' and '&gt;' respectively.

     use warnings;
     use strict;

     sub escape_ents {
       local $_ = shift;
       s/&/&amp;/g;
       s/</&lt;/g;
       s/>/&gt;/g;
       s/"/&quot;/g; # "
       s/'/&apos;/g;
       return $_;
     }

     sub stringify_attribs {
       return join '',
         map{
           ' '.escape_ents( $_ ).'="'.escape_ents( $_[0]{$_} ).'"'
         } sort keys %{$_[0]};
     }

* The XML_elem function

This function is where the XML is generated.  It is used for the rest of this discussion so spend a few moments studying what it does.  It's not too complicated.

The first argument is the name of the XML element.  It is stored in the variable $tag.

If the second argument is a hash reference, then the reference gets stored in $atribs.  Otherwise, $attribs is undefined.

The array @result is where the resulting XML fragments are stored.

The first thing in the @results array is the opening XML tag. If there are attributes stringify_attribs converts them to XML attributes which are output as part of the opening tag.

If there are no other arguments the opening XML tag is turned into an empty element XML tag, returned, and the function exits.

If there *are* remaining arguments they are processed one by one in the foreach loop.  If an argument is a code ref (used to produce XML-sub-elements) then execute the code, and store the results in @results.  If the argument is a string of plain text escape any illegal characters with escape_ents, and store the result in the @results array.

Finally append the closing XML tag to the @results array and return the results to the caller.  XML_elem leaves it up to the caller to concatenate all the results together.

Pretty simple stuff.

    sub XML_elem {
      my $tag = shift;
      my $attribs = shift @_ if( ref( $_[0] ) eq 'HASH' );

      my @results; # return value

      push @results, "<${tag}" . stringify_attribs( $attribs ) . ">";

      if( @_ == 0 ) { # handle an empty element
        $results[0] =~ s|>$| />|;
        return @results;
      }

      foreach my $arg ( @_ ) {
        if( ref( $arg ) eq 'CODE' ) {
          push @results, map{ "  $_" } $arg->(); # <--- ???
        } else {
          push @results, '  ' . escape_ents( $arg )
        }
      }

      push @results, "<\\${tag}>";
      return @results;
    }

* First Attempt

This example, and all the examples in the first half of this writeup should produce three nested XML elements.  The outermost element should have the tag name "root".  Inside the "root" element is the "branch" element, and inside the "branch" element is the "sub-branch" element.  There are some attributes, text contents, and entities to be converted into their XML representation included to complete the example.

Here is the result I'm trying to produce:

    <root ID="0">
      <branch>
        <sub_branch foo="2">
          some contents &amp; entities, &quot;&lt;&gt;&quot;
        </sub_branch>
        other contents
      </branch>
      root stuff
    </root>


The following code fragment demonstrates how I initially planed to use XML_elem to produce XML.  By nesting call to XML_elem, I wanted to produce nested XML elements.

    print join "\n",
      XML_elem( 'root', { ID => 0 },
        XML_elem( 'branch',
          XML_elem( 'sub_branch', { foo => 2 },
            'some contents & entities, "<>"'
          ),
          'other contents',
        ),
      'root stuff',
      );

Do you see what went wrong?  Try the code and see what happens. (Or just read on.)

* The First Results

The source of the problem is complicated.  It has to do with the fundamental way functions are called in perl (and most programming languages).

The problem is Perl evaluates the nested XML_elem functions from the inside out.  The innermost XML_elem function (the 'sub_branch' element) is evaluated first, before the function it is an argument to (the 'branch' element) is called.  When the 'branch' XML_elem function is called all it gets is the @results array from the 'sub_branch' XML_elem function.  The contents of the @results array are all strings.  Some of these strings are XML tags.  So, these XML tags and entities are escaped by escape_ents while they are interpolated into the "branch" element.  Then the @results are escaped again when they are interpolated into the "root" element. The result is a big mess.  It is actually valid XML, but not the XML I wanted.

* The Problem

Since none of the arguments to XML_elem are function references the line marked by "<--- ???"  in XML_elem is never executed.  The way XML_elem is designed it identifies an argument is an XML-sub-element by determining if the argument is a code reference.  If it is a code reference then XML_elem does not escape any entities produced by that argument.  A sub-element's function is responsible for escaping it's own entities.  The enclosing element can't distinguish between 

Note: In the first code fragment the list of results from XML_elem are joined together separated newlines before the results are printed.  XML_elem returns an array so we can, in theory, nest XML elements created in one part of a program inside XML generated in another part of the program.  (It doesn't work at this point but it will soon) The code fragments in this document create the XML fragment all in one place, but, using the final product, you could distribute the creation of the XML elements to wherever it is most convenient.

* Lazy Evaluation

What we need is to prevent the nested XML_elem functions from being evaluated until it's needed inside the calling function.  This is called Lazy Evaluation. Perl can delay the evaluation of a function by passing a code reference as an argument and calling the function through the code reference inside the function, instead of calling the function in the argument list.

The problem is, if we use a function reference, how do we pass arguments to the function when it is called via the reference deep inside nested calls to XML_elem?  The solution is to use a closure to bind the subroutine reference and the arguments together into a function that can be called with no arguments.

* The First Closure

This simple subroutine, called "ml" for make lazy, solves our problem.  Each time it is called it packages the subroutine reference in the variable $sub and all the remaining arguments in the array @args, and returns a reference to an anonymous subroutine.  When the anonymous subroutine is called it simply returns the result of calling the subroutine, via the reference stored in $sub, using the arguments stored in @args.  Using this function we  delay the execution of XML_elem until the anonymous function ml returns is executed.

Since $theFunc and @args are lexical variables, declared with "my", a new set is created each time ml is called.  Additionally, as long as we keep a reference to each subroutine that ml returns, each pair of $theFunc and @args variables are kept.  Perl keeps distinct copies of $theFunc and @args together inside each anonymous subroutine so the pointer to the subroutine implicitly contains the proper $theFunc, and @args variables.  This is the magic of closures used to produce lazy evaluation.

    # ml (Make Lazy) takes a reference to a subroutine as it's 1st arg.  All
    # remaining args are saved and used as arguments for the subroutine when
    # the results of execution are desired.  returns a subroutine that behaves
    # almost exactly as if the subroutine had been called when ml was called.
    sub ml {
      my $theFunc = shift;
      my @args = @_;
      return sub {
        return $theFunc->( @args );
      };
    }

* Second Attempt

This code fragment demonstrates ml in action.  Notice how all the arguments, in the nested function calls, that were passed to XML_elem in the first attempt are now passed to ml preceded by a reference to the XML_elem function.

    print join "\n",
      XML_elem( 'root', { ID => 0 },
        ml( \&XML_elem, 'branch',
          ml( \&XML_elem, 'sub_branch', { foo => 2 },
            'some contents & entities, "<>"'
          ),
          'other contents',
        ),
      'root stuff',
      );

* Currying Arguments Part 1

This works!!!  It produces the desired output, but the function arguments look cluttered.  Some nesting of function calls is desired because it indicates which XML elements are nested inside each other.  But the amount of nesting in fragment 2 seems clumsy, and excessive.  The clumsiness is most prominent in the inconsistency of the indentation scheme.  Poor code layout, of course, does not necessarily mean poor code, but the fact that there is almost no way to consistently layout the code in a way that indicates the code's purpose is a hint that there might be a better design.

So, lets change how we call ml.  Code fragment 2 crams too many arguments of different kinds into ml.  The first argument is a reference to a subroutine.  The second argument is name of the XML tag.  The remaining arguments are the contents of the XML element including an optional attribute hash and sub-elements.  These are all mashed together in one argument list.  You have to count arguments for each function to determine what is what.  Before I learned there was a better way, this argument cramming seemed normal.

It is possible to break argument lists apart.  To specify the subroutine reference and the XML tag name in one place, and the XML element contents and attributes somewhere else.  This is called currying arguments.

To curry the arguments to ml we call one function with a reference to the XML_elem subroutine and the tag name in one place, then, somewhere else supply the remaining XML entity contents.

Currying arguments requires keeping track of which functions have been called with which arguments, and what remaining arguments are needed.  What happens is, when the first arguments are supplied the function returns a reference to an anonymous function that takes the remaining arguments.  In the code fragment below the anonymous function pointers are stored in variables whose names are the names of the XML tags.  This makes it easy to track which arguments go with which functions.

Some languages implement currying automatically.  If you don't supply enough arguments to a function it curries those arguments and returns an anonymous function where you supply the rest of the arguments.  With Perl you have to be a little more explicit.  Fortunately, Perl implements currying using our old friend the closure.  Our closure simply stores the first two arguments to ml in lexical variables, and returns a subroutine which takes the remaining arguments and then calls ml.

    # ca4ml (Curry Arguments for ML)
    sub ca4ml {
      my $sub = shift;
      my $tag = shift;
      return sub {
        my @args = @_;
        return ml( $sub, $tag, @args );
      }
    }

    my $root       = ca4ml( \&XML_elem, 'root' );
    my $branch     = ca4ml( \&XML_elem, 'branch' );
    my $sub_branch = ca4ml( \&XML_elem, 'sub_branch' );

    print join "\n",
      $root->( { ID => 0 },
        $branch->(
          $sub_branch->( { foo => 2 },
          	 'some contents & entities "<>"'
          ),
          'other contents',
        ),
        'root stuff',
      )->();

* Currying Results

Doesn't this code fragment look much nicer than the previous code fragment.  It is much easier to see which XML attributes and contents go in which entities.  The code which produces the XML mimics the XML layout almost exactly.

The tricky part is the final anonymous function call indicated by the ")->()" in the last line of the code fragment.  Remember, ml returns an anonymous function.  If we don't execute the outermost anonymous function no XML is produced.  In fact, XML_elem is not called until that anonymous subroutine is executed.  Up to that point all we've done is assemble a hierarchy of anonymous functions and argument lists which contain more anonymous functions. We must execute the outermost anonymous function to actually produce the XML.

One other issue with this implementation can be improved.  Notice that the first argument to ca4ml is always a reference to the subroutine XML_elem.  It always will be.  If we know what an argument will be we don't need to pass it as an argument.

This example shows this change in action.  I changed the name from ca4ml to make_func.  The anonymous functions this function returns are the only interface to this XML writing technique.

    sub make_func {
      my $tag = shift;
      return sub {
        my @args = @_;
        return ml( \&XML_elem, $tag, @args );
      }
    }

    $root       = make_func( 'root' );
    $branch     = make_func( 'branch' );
    $sub_branch = make_func( 'sub_branch' );

    print join "\n",
      $root->( { ID => 0 },
        $branch->(
          $sub_branch->( { foo => 2 },
    	 'some contents & entities "<>"'
          ),
          'other contents',
        ),
        'root stuff',
      )->();

* The Story So Far ...

In the introduction I said I was looking for a package which wrote XML using this nested function paradigm.  What we have so far is not a package but it can easily be turned into a package with a rather novel interface.  The title mentions overloaded operators; Notice, I haven't overloaded any operators yet.  You need to have a package to overload operators.

* Starting Over

At this point we are going to create the package described in the introduction.  The following code fragments augment/replace the code fragments listed above, so you can't just copy them into the same perl file without producing errors.  Either start a new file or open the func_writer.pl file, and follow along.

* Introduction to XML::FuncWriter

The interface for this module is rather novel in that the user specifies the functions he/she wants in the use statement, and this library creates the desired functions at compile time and installs them in the calling packages namespace.  The funtions the user wants don't exist until the user asks for them!

Also, There were two main issues in the previous implementation that are fixed here.

The first improvement removes the dangling function call that cause all the lazy evaluation to occur.  It is to easy to forget the "->()" at the end, and end up with "CODE(0x1b41244)" in your output where you expected XML.  It also removes the need to join all returned @result elements together to produce a single output string as the result.

The second improvement is the addition of what is called the distributive property in the CGI.pm documentation.  The following is a portion of the documentation from CGI.pm

    One of the cool features of the HTML shortcuts is that they are
    distributive. If you give them an argument consisting of a reference to a
    list, the tag will be distributed across each element of the list. For
    example, here's one way to make an ordered list:
       print ul(
                 li({-type=>'disc'},['Sneezy','Doc','Sleepy','Happy'])
               );
    This example will result in HTML output that looks like this:
       <ul>
         <li type="disc">Sneezy</li>
         <li type="disc">Doc</li>
         <li type="disc">Sleepy</li>
         <li type="disc">Happy</li>
       </ul>

This library lets you do the same thing with any XML tag you want.

There are other changes and refactoring that I will describe below.  The first is, of course, the addition of the package declaration.

    package XML::FuncWriter;

    use warnings;
    use strict;

    sub escape_ents {
      local $_ = shift;
      s/&/&amp;/g;
      s/</&lt;/g;
      s/>/&gt;/g;
      s/"/&quot;/g; # "
      s/'/&apos;/g;
      return $_;
    }

    sub stringify_attribs {
      return join '',
        map{
          ' '.escape_ents( $_ ).'="'.escape_ents( $_[0]{$_} ).'"'
        } sort keys %{$_[0]};
    }

Apart from the package declaration this code is exactly the same.

To generate functions on-the-fly requires a custom import function instead of using the perl exporter module.  However the import funtion is not that complicated.

    sub import {
      my $pkg = shift;
      my $callpkg = caller( 0 );

      foreach my $func ( @_ ) {
        no strict 'refs';
        *{"$callpkg\::$func"} = make_func( $func );
      }
    }

XML_elem also requires a change to implement the Distributive Property for XML tags.  

    sub XML_elem {
      my $tag = shift;
      my $indent = shift;
      my @res; # return value

      my $attribs = shift @_ if( ref( $_[0] ) eq 'HASH' );
      my $open_tag = "<${tag}" . stringify_attribs( $attribs ) . ">";

      # handle an empty element
      $open_tag =~ s|>$| />| && return $open_tag if( @_ == 0 );

      my $close_tag = "</${tag}>";

      if( @_ == 1 && ref $_[0] eq 'ARRAY' ) {
        # Argument is an anonymous array. (distributive property)
        # Each element gets it's own pair of tags
        foreach my $arg ( @{ $_[0] } ) {
          push @res,
            $open_tag, recurse_if_code( $indent, $arg ), $close_tag;
        }
      } else {
        # Concatinate all arguments between 1 pair of tags.
        push @res,
          $open_tag, map( { recurse_if_code( $indent, $_ ) } @_ ), $close_tag;
      }
      return @res;
    }

The code in XML_elem that implements the recursion is mixed in with the code that implements the distributive property.  So, I refactored the recursion into the function recurse_if_code.  The 'not root' argument is explained below.

    sub recurse_if_code{
      my $indent = shift;
      my $arg = shift;

      return map { $indent . $_ } $arg->( 'not root' )
        if( ref( $arg ) eq __PACKAGE__ );

      return $indent . escape_ents( $arg )
    }

I moved the funtionality of the ml (make lazy) function from the parent node into make_func since that was the only place it was called.  This makes make_func a bit more complicated, but it consolidates all the wizard stuff in one function (except the operator overloading stuff, which we'll get to in a minute). 

Since the library also handles concatenating the results of XML_elem into one string when desired it should also allow the user to specify how they would like the whitespace handled in the resulting XML.  This is handled by allowing the user to specify two named arguments in an anonymous hash to the final anonymous function to produce the XML string.  The argument specified by indent is prepended to each line once for each level of element nesting. Unless the user is doing something weird it should just be a string of white space.  The default is two spaces.  The argument specified by line_sep is used to join all the XML elements together.

    # The outer closure curries one argument, the tag name, The second closure
    # causes lazy evaluation of the subroutine XML_elem. It also curries
    # information for formating the resulting XML fragment.  The second closure is
    # blessed into the current package so the XML string gets written when the
    # user wants it.

    sub make_func {
      my $tag = shift;
      return sub {  # curry XML tag name
        my @args = @_;
        return bless sub { # Lazy evaluation of XML_elem

          my %format_info = ( indent => '  ', line_sep => "\n" );

          %format_info = ( %format_info, %{shift( @_ )} )
    	  if( defined $_[0] && ref $_[0] eq 'HASH' );

          # create all the XML elements
          my @res = XML_elem( $tag, $format_info{indent}, @args );

          # NOT Root Element - Don't concatinate elements.
          return @res if( $_[0] && $_[0] eq 'not root' );

          # Root Element - Concatinate results.
          return join $format_info{line_sep}, @res;
        }, __PACKAGE__;
      }
    }

make_func blesses the final anonymous function, turning it into a XML::FuncWriter object.  (Yes, an anonymous function can be an object in Perl.) The reason for this is operator overloading requires one of the operands be an object with the operator overloaded.

"Wait, why do you want to overload an operator?" I hear you ask.  "Isn't the interface to this library is a bunch of named and unnamed anonymous functions?"

Yes.  That's the problem.  After we build up this structure of anonymous functions what we *get* is an anonymous function representing the root object of the XML.  What we *want* is a string containing the XML produced by calling that function.  In the examples in the first half we manually called the anonymous function with the dangling ")->()".

We want to override the stringification operator.  Actually, until we want to print it out, or otherwise deliver XML to the world, we would like to keep it an anonymous function.  As long as it remains an anonymous function we can use it in one or more other calls to other XML generating functions.  (Yes, you can use the same fragment of XML in multiple places in a larger XML fragment, or in multiple other XML fragments.)  But, the moment you print it or concatenate it with another string it should magically convert that anonymous function into the desired string of XML.

    use overload
      '""'  => sub { $_[0]->() },
      'cmp' => sub { return $_[2] ? $_[1] cmp $_[0]->() : $_[0]->() cmp $_[1] };

I discovered the need to overload the cmp operator while testing the module
with Test::more.  (An interesting case of testing uncovering a bug of
omission.)
